\documentclass[10pt]{article}
\usepackage{a4wide}
\usepackage[final]{epsfig}
\include{macros}
\include{pathmacros}

\begin{document}

\begin{center}
{\Large\bf
\texttt{libPkgDep} Documentation \\[\baselineskip]
}
{\large
Roman Hodek \texttt{<Roman.Hodek@informatik.uni-erlangen.de>} \\
December 1999
}
\end{center}
\vspace{1cm}

\tableofcontents
\newpage


% ===========================================================================


\section{Introduction}

\file{libPkgDep} can simulate package installation and detect and
(partially) solve problems that happen during this. It's main purpose
is to expand a list of packages that the user wants to install to a
list that is actually installable, if one takes requirements and
conflicts into account.

The installation simulation is done by an object of type
\class{PkgDep}. Such an object internally stores two sets of packages:
An {\em installed} set, which are the packages that are considered to
be already installed. And an {\em available} set that tells the object
which objects would be available for installing them if needed. A
typical application would be that the installed set contains the
packages currently installed on the system, and the available set are
all packages contained on the current distribution CD-ROM.

For the simuation you first have to create a \class{PkgDep} object
with appropriate installed and available sets. Then you can call the
\meth{install} method, passing a candidate set containing the packages
you want to install.

During package installation, a number of problems can happen and
\file{libPkgDep} tries to solve them as far as this is possible
automatically. For example, it could happen that a candidate package
requires some other package which isn't installed yet but which is
available. The simulation then automatically adds this package and
continues, maybe adding more packages if needed. Another more
complicated example for a possible problem is that upgrading a package
breaks the requirements of an installed package. In this case the
library tries to fix the broken dependency by either installing
something to satisfy the requirement, or to upgrade the requirer to
remove the broken dependency.

The general philosophy of \file{libPkgDep} when installing is to do as
much as possible, even in spite of errors. So the results are to
interpreted as ``this can be installed if all the errors are fixed'',
and not as ``this is what you can install now''. This means the good
list may contain packages that require other packages that have an
error. If you want the more conservative behaviour, it's still easy to
remove good packages that refer to a bad one (with help of the
\val{referer} field).

The results of the simulation run are returned in two lists: a good
list and a bad list. The good list contains all the packages that
didn't have unfixable problems. It consists of the candidates plus any
packages added to fulfill requirements etc. The bad list tells you
about all the errors that happened, i.e. conflicts, unsatisfyable
requirements\dots

If a simulated installation was ok (i.e., no errors were detected),
the packages on the good list are committed to the internal installed
list of the \class{PkgDep} object. This means you can try to install a
few packages, and if this was ok, try to install some more an so on.
Or a graphical frontend could call \meth{install} every time the user
selects a package for installtion and instantly check this package for
installability.

There are some more methods for a \class{PkgDep} object: \meth{remove}
can simulate removing packages as counterpart of installing them. This
affects the internal installed list as well as it does also removes
packages whose requirements are now broken. The \meth{consistent}
method allows for checking consistency of package relations in the
current installed set.

Finally, the \meth{upgrade} method is a somewhat intelligent algorithm
for upgrading the packages of a system. It finds out which upgrades
are available and tries to install them and fixes as many problems
automatically as possible (even more than \meth{install}).


% ===========================================================================

\section{Interface of \class{PkgDep}}
\currentclass{PkgDep}

% ---------------------------------------------------------------------------

\subsection{Types}

The following types are used to return results of dependency checking,
or \type{alternatives_mode} to select operation modes. For all types
except the enumerations shift-out operators are defined by
\file{libPkgDep} for easy printing.

\ctype{alternative_kind}
This enumeration type is used to describe the characteristics of a found
alternative. The values are
\begin{description}
\item[\val{SIMPLE}:]
  The package can be installed without further trouble and doesn't
  even require more packages.
\item[\val{REQUIRES_MORE}:]
  The package can be installed, but it has yet unsatisfied
  requirements, i.e. it will pull in more packages.
\item[\val{CONFLICT}:]
  The package is in conflict with an already installed package.
\end{description}

\ctype{alternatives_mode}
This enumeration is a list of the possible modes how to handle
alternatives:
\begin{description}
\item[\val{ASK_ALWAYS}:]
  Never try to select an alternative automatically.
\item[\val{ASK_IF_NO_DEFAULT}:]
  If a default is found for the virtual package to be installed, use
  it. Otherwise make no automatic decision, but give back an
  \class{ErrorResult} with a non-empty alternatives list.
\item[\val{AUTO_IF_NO_DEFAULT}:]
  If a default is found for the virtual package to be installed, use
  it. Otherwise automatically chose a package, first ones that can be
  directly installed, than ones that require additional packages, and
  last packages conflicting with something installed. Within each of
  the classes, the decision is non-deterministic.
\item[\val{AUTO_ALWAYS}:]
  Automatically chose an alternative as described above, but ignore
  defaults.
\end{description}

\ctype{RelInfo}
This is a helper structure used by result lists to describe a single
relation. It contains the following fields:
\begin{description}
\item[\val{PkgName name}:]
  Name of the package causing the relation.
\item[\val{PkgRelation rel}:]
  The relation itself, containing the name of the target package and
  optionally a version condition.
\item[\val{bool is_conflict}:]
  Is \true\ if the relation is a conflict and \false\ if it's a
  requirement.
\end{description}

\ctypedef{list<PkgName>}{NameList}
\ctypedef{NameList::iterator}{NameList_iterator}
\ctypedef{NameList::const_iterator}{NameList_const_iterator}
This is simply an alias for a list of \class{PkgName}s as an
abbreviation, and the associated iterators. Note that \file{libPkgDep}
also defines a shift-out operator for this type.

\ctypedef{list<RelInfo>}{RelInfoList}
\ctypedef{RelInfoList::iterator}{RelInfoList_iterator}
\ctypedef{RelInfoList::const_iterator}{RelInfoList_const_iterator}
This defines a list of \class{RelInfo} structures and its iterators.

\ctype{Alternative}
This is another helper structure for describing alternatives. It just
glues together a package name and its \class{alternative_kind}. The
names of the components are \val{name} and \val{kind}.

\ctype{NeededEditionRange}
This structure is used to give details for unresolvable packages. It
describes what edition of the package would be required to resolve the
dependency on it. The \class{PkgEdition} components \val{greater} and
\val{less} define the range: The required version must be greater than
\val{greater} and less than \val{less}. The two flags
\val{greater_incl} and \val{less_incl} are \true\ if the borders are
included in the allowed range, too.

If either the lower or upper border is undefined (i.e., an arbitrarily
low or high version is allowed), the value is
\val{PkgEdition(PkgEdition::UNSPEC)}. Two utility member functions
give basic information about the edition range: \meth{allows_any}
return \true\ if any edition is ok, i.e. both \val{greater} and
\val{less} are unspecified. \meth{impossible} is \true\ if
requirements on the package are contradicting. Technically, this is
the case if \val{less} < \val{greater}.

\ctype{Result}
This is the basic return type for packages that could be processed
without problems. It contains further information about the package:
\begin{description}
\item[\val{PkgName name}:]
  The name of the package this result is for.

\item[\val{PkgEdition edition}:]
  The edition to be installed.

\item[\val{RelInfoList referers}:]
  A list of packages that require the package described by the
  \class{Result}. Please note that a referer is remembered only if no
  installed package would have satisfied the requirement, too.

\item[\val{PkgEdition is_upgrade_from}:]
  This is the installed version of the package if the installed
  version is less. If the package isn't installed yet, the value is
  the unspecified version.

\item[\val{PkgEdition is_downgrade_from}:]
  This is the installed version of the package if the installed
  version is greater. If the package isn't installed yet, the value is
  the unspecified version.

\item[\val{bool from_input_list}:]
  This flag is \true\ if the package was on the input list of the
  install run. It's \false\ if the package has been added by
  \file{libPkgDep} to solve requirements or the like.

\item[\val{bool upgrade_to_remove_conflict}:]
  This flag is set if the package has been upgraded to resolve a
  conflict with a new package that would have existed otherwise.

\item[\val{bool install_to_avoid_break}:]
  This flag is set if the package has been added automatically to
  avoid a broken requirement.
\end{description}


\ctype{ErrorResult}
The \class{ErrorResult} structure is derived from \class{Result} and
thus also contains its fields. It additionally carries information
about errors that happened:
\begin{description}
\item[\val{bool not_available}:]
  This flag is set if the package is not available (but would be needed).

\item[\val{NeededEditionRange not_avail_range}:]
  This field gives details about the editions that would be needed to
  satisfy the requirements. For interpretation, see the description of
  \class{NeededEditionRange} above. It's meaningful only if
  \val{not_available} is set. Otherwise,
  \val{not_avail_range.allows_any()} is \true.

\item[\val{RelInfoList unresolvable}:]
  This lists the requirements of the package that could not be
  resolved. The \class{RelInfo}s can never be conflicts. For each
  missing package, there's a separate entry in the error result list
  with \val{not_available} set.

\item[\val{list<Alternative> alternatives}:]
  If this list is not empty, it means that the package is a virtual
  package and there is more than one real package that provides it,
  and that the alternative has not been solved automatically. The
  \class{Alternative}s give the name of each possible alternative and
  its kind (simple, requires more, generates a conflict).

\item[\val{RelInfoList conflicts_with}:]
  This field lists all kinds of conflicts of the package with
  installed packages or other packages to be installed. The
  \class{RelInfo}s can be requirements or conflicts. An entry can be
  generated if:
  \begin{enumerate}
  \item
    if an already installed package conflicts with the new one
  \item
    if the new package conflicts with an installed one
  \item
    if a previously satisfied requirement of an installed package is
    broken by installing (probably upgrading) this package (in this
    case \val{is_conflict} in the \class{RelInfo} is unset)
  \end{enumerate}

\item[\val{NameList remove_to_solve_conflict}:]
  This is an auxiliary field to \val{conflicts_with}. The conflicts
  disappear if all the packages listed would be removed.

  This list is generated by a rather simple algorithm and does not
  have any knowledge about the installation. If something conflicts
  with libc, expect that the list contains nearly all installed
  packages :-)

\end{description}

% ---------------------------------------------------------------------------

\subsection{Constructors}

\cconst{PkgDep}{PkgSet& instd, const PkgSet& avail, alternatives_mode m = default_alternatives_mode}
This constructs a \class{PkgDep} object with given installed and
available sets.

\cconst{PkgDep}{const PkgSet& instd, alternatives_mode m = default_alternatives_mode}
In this variation, the default available set is used as the available
set of the object.

\cconst{PkgDep}{alternatives_mode m = default_alternatives_mode}
In this variation, the default available set is used as the available
set, and the currently installed package on the system as installed set.

% ---------------------------------------------------------------------------

\subsection{Working}
\cmeth{bool}{install}{PkgSet& candidates, ResultList& good,
ErrorResultList& bad, bool commit_to_installed = true}
This tries to install the packages in the \var{candidates} set into a
virtual system represented by the object's installed set. All
candidates must be members of the object's available set. It is
possible that more packages from the available set are used if there
are unsatisfied requirements.

In \var{good} a list of packages that are installable is returned.
These are the candidates plus maybe some more that are needed to
satisfy requirements. The \var{bad} list returns error notifications
about problems that have been encountered (see description of the
\class{ErrorResult} structure). The return value of \meth{install} is
\true\ if and only if the \var{bad} list is empty.

In the normal case, if there are no errors, all good packages are
committed to the internal installed set of the \class{PkgDep} object
to support incremental installation simulations. If this is unwanted,
the committing can be suppressed by passing \false\ for
\var{commit_to_installed}.

\cmeth{void}{remove}{NameList& pkgs}
Simulate removing the packages in \var{pkgs}. All other packages whose
requirements are not satisfied anymore are removed, too. The returned
\var{pkgs} list has been extended by those additional packages after
return. The packages are also removed from the internal installed set.

\cmeth{bool}{consistent}{ErrorResultList& failures}
This method tests the internal installed set for consistency. All
requirements and conflicts are check and any errors are reported in
the \var{failures} list (which should contains only \val{unresolved},
\val{is_unavailable}, and \val{conflicts_with} records). The return
value is \true\ if and only if there are no errors.

\cmeth{bool}{upgrade}{ResultList& out_good, ErrorResultList& out_bad, NameList& to_remove, unsigned max_remove = default_max_remove}
This method tries to upgrade the installation represented by the
\class{PkgDep} object. It searches the available set for newer
versions of installed packages, and for packages obsoleting installed
ones. Those are treated as candidates and tried to install.

Furthermore, \meth{upgrade} tries to fix problems as far as this is
possible automatically. If an upgrade has unsatisfyable requirements,
it is left out. If there are alternatives that have not been handled
by the alternatives mode of the object, simply the first alternative
is selected. And if an upgrade package has a conflict, the packages
listed in \val{remove_to_solve_conflict} are removed if they aren't
too many (not more than \var{max_remove}). After all these problems
have been handled, installation is retried. The process is iterated
until there are no errors anymore, or it seems an endless loop would
happen.

% ---------------------------------------------------------------------------

\subsection{Setting Defaults}

\cmeth{static void}{set_default_available}{const PkgSet& av}
Selects the default available set for new \class{PkgDep} objects. This
set is used if a constructor without an explicit available set is used.

\cmeth{static void}{set_default_alternatives_mode}{alternatives_mode m}
Selects the default mode for alternatives handling. This mode is used
if the corresponding parameter to the constructor is left out.

\cmeth{static void}{set_default_max_remove}{unsigned mr}
Selects the default \var{max_remove} threshold for the \meth{upgrade}
method.


% ===========================================================================

\section{Algorithms}

% ---------------------------------------------------------------------------

\subsection{Installation}

The installation algorithm loops over candidate packages and checks
them one by one. During checking, it can happen that new candidates
are added. Candidates that are already installed are silently dropped
and do not appear in the final \var{good} list.

If all packages that need checking are handled, stored alternatives
are processed. This is delayed for the \val{requires_more} alternative
kind. If a package requires more than would be installed anyway can be
determined only after all installations have been done.

Since alternative handling can add packages again that need checking,
the process starts again until all lists are empty.

\begin{quote}
\begin{verbatim}
to_check := candidates;
do
  while to_check not empty
    take a package out of to_check
    check it
  while alternatives_to_check not empty
    take a package out of alternatives_to_check
    handle it
while to_check not empty
\end{verbatim}
\end{quote}

(This cannot result in an endless loop, as there is a limited number
of packages that can be added to the \val{to_check} lists.)

During the checks, accepted packages are added to a virtual installed
set (\val{vinstalled}). \val{vinstalled} is a union of the previously
installed packages and the accepted packages, where upgraded packages
of course appear only once. The term ``installed'' below stands for a
package in the \val{vinstalled} set.

The checks for a single package (the candidate) are:
\begin{itemize}
\item
  Check if the candidates is obsoleted by an installed package. If
  yes, the installation would fail and the candidate is dropped.

\item
  Check if an installed package $I$ is obsoleted by the candidate $C$.
  If yes, check for broken requirements by replacing $I$ by $C$. A
  broken requirement is tried to fix by upgrading $I$ if possible.

\item
  Check if an installed package $I$ has a conflict with the candidate
  $C$. If yes, first try to upgrade $I$ and see if this removes the
  conflict. Otherwise, report a conflict on $C$.

\item
  Check if the candidate $C$ has a conflict with an installed package
  $I$. If yes, first try to upgrade $I$ and see if this removes the
  conflict. Otherwise, report a conflict on $C$.

\item
  Check if the candidate $C$ conflicts with at least one other (not
  yet accepted) candidate. If this is the case and $C$ conflicts with
  itself and all the conflict targets are the same name, this
  situation is treated like an alternative. All the conflicting
  packages are taken out of the candidate set and handled later
  together with alternatives.

\item
  Check if the requirements of an installed package would be broken by
  installing the candidate (which must be an upgrade to an existing
  package). If there is such a package $I$, try to upgrade it to get
  rid of the bad requirement.

\item
  Check all requirements of the candidate. If an installed or
  candidate package provides what is required, no further action is
  needed. Otherwise, the available set is searched for a provider. If
  there's exactly one, this package is added as a new candidate. If
  there is none, the candidate is unsatisfied. If there are more than
  one providers, this is an alternative and the candidate is delayed
  and handled later with the alternatives.
\end{itemize}

The alternatives handling works as follows:
\begin{itemize}
\item
  First, all the possible alternatives are checked (with
  \meth{consistency}) if they themselves require more packages or if
  they conflict with something installed. Alternative kinds are
  assigned according to the results of this test.

\item
  If the alternatives mode is \val{ASK_ALWAYS}, break here and
  generate an alternatives error result.

\item
  If the mode is \val{ASK_IF_NO_DEFAULT} or \val{AUTO_IF_NO_DEFAULT},
  the alternative defaults list is searched for an entry for the
  candidate. Then all the found defaults are checked for validity,
  i.e. if they exist and really satisfy the requirement that caused
  the alternatives handling. If any of the defaults is ok, the first
  one ---without a new conflict if possible~--- is selected.
  Otherwise, \val{ASK_IF_NO_DEFAULT} aborts and generates an error
  result. \val{AUTO_IF_NO_DEFAULT} falls through and continues as
  \val{AUTO_ALWAYS} below.

\item
  The val{AUTO_ALWAYS} mode selects a random alternative, but first
  one with kind \val{SIMPLE} (no further requirements), then
  \val{REQUIRES_MORE}, and last {CONFLICT}.

\item
  If an alternative has been selected somehow, it is added as a new
  candidate, and the old candidate who caused the alternatives
  handling is accepted.

  If nothing has been selected, an error result is generated with the
  \val{alternatives} list set to the known list of alternatives. The
  original candidate is considered unresolvable.
\end{itemize}


% ---------------------------------------------------------------------------

\subsection{Removing}

The removing of packages is done by a simple recursive approach: If a
package is removed, all requirements with the package as target are
checked. If the removed package was the last provider for the
requirement, the requiring package has to be removed, too.

% ---------------------------------------------------------------------------

\subsection{Consistency}

Consistency checking is rather simple, too: All requirements and
conflicts of all installed packages are checked. If no provider
(requirement) or any provider (conflict) is found, an error result for
the package is generated.

% ---------------------------------------------------------------------------

\subsection{Upgrade}

The first step of the \meth{upgrade} method is to construct the
candidate set: All available packages that are newer versions of
already installed packages are added. Also available packages that
obsolete an installed one are added.

Then there's a loop that tries to install the current candidates and
then checks for fixable problems. This loop is repeated as long as the
installation fails and occuring problems can be fixed. As a safeguard,
the loop is aborted after 100 iterators, as it seems it would continue
endlessly.

The fixable problems are:
\begin{itemize}
\item
  Packages with unsatisfied requirements are removed from the
  candidates set.

\item
  If there are yet unhandled alternatives, simply the first
  alternative is selected.

\item
  If a candidate has conflicts, the packages listed in
  \val{remove_to_solve_conflict} are removed to allow its
  installation. However, again as a safeguard, this happens only if
  these are not more than \var{max_remove} packages (default 10).

\end{itemize}


% ===========================================================================

\section{Examples}

\subsection{Simple Installation}

Assume the available packages are in \file{/cdrom/COL2.3}. Then the
following program is a simple command line interface to
\file{libPkgDep}. It simulates installation of the arguments and
prints a verbose result, i.e. also the annotation to the packages.

\begin{verbatim}
#include <PkgDep.h>
#include <PkgDb.h>

int main( int argc, char *argv[] )
{
    // add packages to the pool
    PkgPool.add_installed_packages();
    PkgPool.add_source( "/cdrom/COL2.3", "Avail" );

    // build sets
    PkgSet installed( DTagListI0() );
    PkgSet available( DTagList1("Avail") );

    // build candidate set
    PkgSet candidates;
    for( int i = 1; i < argc; ++i ) {
        PkgName name( argv[i] );
        if (available.includes( name ))
            candidates.add( available[name] );
        else
            cerr << argv[i] << ": no such package available\n";
    }
    
    // construct PkgDep object
    PkgDep engine( installed, available );
    // call install
    PkgDep::ResultList good;
    PkgDep::ErrorResultList bad;
    bool result = engine.install( candidates, good, bad );

    // print results    
    for( PkgDep::ResultList::const_iterator p = good.begin();
         p != good.end(); ++p ) {
        cout << *p << endl;
    }
    for( PkgDep::ErrorResultList::const_iterator p = bad.begin();
         p != bad.end(); ++p ) {
        cout << *p << endl;
    }

    // finally check consistency of new installed set
    PkgDep::ErrorResultList fails;
    if (!engine.consistent( fails )) {
        cout << "consistency check after install() failed:\n";
        for( PkgDep::ErrorResultList::const_iterator p = fails.begin();
             p != fails.end(); ++p )
            cout << *p << endl;
    }

    return result ? 0 : 1;
}
\end{verbatim}


\subsection{Upgrade}

The following program simulates a full upgrade of the system and
simply prints the names of the packages that should be installed or
removed:

\begin{verbatim}
#include <PkgDep.h>
#include <PkgDb.h>

int main( int argc, char *argv[] )
{
    // add packages to the pool
    PkgPool.add_installed_packages();
    PkgPool.add_source( "/cdrom/COL2.3", "Avail" );

    // build sets
    PkgSet installed( DTagListI0() );
    PkgSet available( DTagList1("Avail") );

    // construct PkgDep object
    PkgDep engine( installed, available );

    // call upgrade
    PkgDep::ResultList good;
    PkgDep::ErrorResultList bad;
    PkgDep::NameList to_remove;
    if (!engine.upgrade( good, bad, to_remove )) {
        // if it failed, print problems
        cout << "Upgrade failed:";
        for( PkgDep::ErrorResultList::const_iterator p = bad.begin();
             p != bad.end(); ++p ) {
            cout << *p << endl;
        }
        return 1;
    }

    // otherwise, print what should be installed and what removed
    for( PkgDep::ResultList::const_iterator p = good.begin();
         p != good.end(); ++p ) {
        cout << "install " << p->name << endl;
    }
    for( PkgDep::NameList::const_iterator p = to_remove.begin();
         p != to_remove.end(); ++p ) {
        cout << "remove " << *p << endl;
    }
    return 0;
}
\end{verbatim}


\end{document}
