\documentclass[10pt]{article}
\usepackage{a4wide}
\usepackage{german}

\parskip 0.7\baselineskip
\parindent 0pt

\begin{document}
\begin{center}
\Large\bf
Entwurf der Datenstrukturen (v1.2)
\end{center}
\vspace{1cm}

\section{Grundlegende Klassen}
\begin{description}
\item[\texttt{PkgName}:]
Paketname; der zugrundeliegende String ist nicht modifizierbar;
au"serdem existiert zu einem String h"ochstens ein Zeiger (siehe
"`Paket-IDs"'), so da"s \texttt{PkgName}s durch Zeigervergleich auf
Gleichheit getestet werden k"onnen.

\item[\texttt{PkgEdition}:]
eine Versionsnummer; hat zus"atzliche Spezialwerte f"ur "`undefinierte
Version"' und "`maximale Version"' \\
Methode \texttt{bool compare(CmpOp, PkgEdition)}
und/oder relationale Operatoren \\
Komponenten (f"ur rpm) sind Version, Release und Serial.

\item[\texttt{PkgNameEd}:]
Hilfsklasse; fa"st PkgName und PkgEdition zusammen

\item[\texttt{PkgRelation}:]
Angabe einer Relation zwischen Paketen (Requires, Conflicts, etc.),
d.h. Paketname plus optional Versionsrelation
\begin{verbatim}
class PkgRelation {
  PkgName name;
  CmpOp op;
  Version version;
\end{verbatim}
\texttt{CmpOP} kann =, $<$, $\le$, \dots sein oder ein spezieller Wert
f"ur "`keine Versionsanforderung"' \\
Methode \texttt{bool satisfied\_by(PkgName, PkgEdition)}

\item[\texttt{PkgRevRelation}:]
Hilfsklasse f"ur Speicherung der invertierten Relationen;
Zusammenfassung von PkgRelation\& (Verweis auf die verursachende
Relation) und PkgNameEd (R"uckverweis auf verursachendes Paket)

\item[\texttt{DistTag}:]
Ein abstrakter Typ, der zusammengeh"orende Pakete kennzeichnet. Die
Implementation werden wohl einfache Strings sein, z.B. \verb+"1.3"+,
\verb+"2.2"+, usw. f"ur Versionen der Distribution, aber auch z.B.
\verb+"1.3-updates"+, \verb+"my-own-packages"+ etc. sind m"oglich.
Ein spezieller Wert ist \verb+"INSTALLED"+ f"ur die Menge der
installierten Pakete. \texttt{DistTag} ben"otigt keine speziellen
Methoden au"ser geeigneten Konstruktoren und einem Gleichheitstest.

\end{description}


\section{Paketnamen}
Die String-Repr"asentation von Paketnamen wird eindeutig gehalten,
d.h. zu einem Namen gibt es nur einen String im Speicher. Dies spart
zum einen etwas Speicher, zum anderen erm"oglicht es aber, Paketnamen
durch einen einfachen Zeigervergleich auf Gleichheit zu pr"ufen. Dies
ist offensichtlich deutlich schneller als \texttt{strcmp()}. Auch
Hashfunktionen k"onnen schneller berechnet werden, da nicht "uber alle
Zeichen eines Strings iteriert werden mu"s.

Die Eindeutigkeit werden von der Klasse \texttt{PkgName} in
Zusammenarbeit mit einem globalen Hash \texttt{PkgNameHash}
gew"ahrleistet. Mit Hilfe des Hashes kann schnell festgestellt werden,
ob ein bestimmter Name bereits gespeichert ist und dessen \verb+char *+ 
wiederverwendet werden.


\section{Paket-Pool und \texttt{PkgDb}}
Im Paketpool werden die Daten zu allen bekannten Paketen gespeichert.
Er ist ein Hash mit Schl"ussel \texttt{PkgNameEd} und Werten vom Typ
\texttt{Package}. Implementiert wird der Pool durch die Klasse
\texttt{PkgDb}, von der nur 1 Objekt gen"ugt.

Der Pool erspart nur mehrfaches Speichern von Paketdaten, wenn eine
Version eines Pakets in mehreren Releases gleich ist, und auch für die
installed- und candidates-Mengen.

\texttt{PkgDb} stellt eine Methode \texttt{add\_source} zur
Verf"ugung, mit der die Daten aller Pakete aus einer bestimmten Quelle
in den Pool eingef"ugt werden k"onnen. Parameter f"ur
\texttt{add\_source} ist zum einen ein \texttt{DistTag}, mit dem die
so gefundenen Pakete versehen werden sollen, zum anderen eine Angabe,
woher die Paketdaten genommen werden sollen; meist wird dies ein Pfad
bzw. URL sein, es k"onnen aber auch andere Methoden definiert werden.
Eine davon ist das Lesen von \texttt{/var/lib/rpm/packages.rpm} zum
Einlesen der installierten Pakete.

Wenn ein Pfad/URL verwendet wird, wird zuerst nach einer Datei
\texttt{PACKAGE-INFOS} gesucht, die ---wenn sie existiert--- eine
Zusammenfassung der Daten darstellt, die sonst aus den rpms extrahiert
w"urden.

"Ahnlich k"onnte man auch eine Datei \texttt{RELEASE} o."a. vorsehen,
aus der das \texttt{DistTag} f"ur die Pakete des Verzeichnisses
gelesen wird.

Eine weitere wichtige Methode von \texttt{PkgDb} ist
\texttt{make\_set}, das ein \texttt{PkgSet} zusammenstellt. Parameter
von \texttt{make\_set} ist eine Liste von \texttt{DistTag}s. Alle
Pakete, die mindestens eines dieser Tags besitzen, werden in das Set
aufgenommen. (Alternativ kann ein \texttt{PkgSet} nat"urlich auch
inkrementell aus bestimmten Paketen zusammengestellt werden.)


\section{Paketdaten: \texttt{Package}-Klassen}
Die eigentlichen Paketdaten werden in der Klasse \texttt{Package}
gespeichert.

\begin{verbatim}
class Package {
  // Name+Version sind auch Schl"ussel
  PkgID _name;
  PkgEdition _edition;
  // Liste der Releases, in der dieses Paket enthalten ist
  list<DistTag> _in_distribs;
  // Paketrelationen (von der Engine ben"otigt)
  list<PkgRelation> needs, conflicts, provides, obsoletes;
  // Angabe, woher die Paketdaten stammen (f"ur das Nachladen)
  PkgDataSource _source;
  // weitere Daten (f"ur Oberfl"ache; nicht unbedingt vollst"andig
  // oder alles sinnvoll! Bitte kommentieren!)
  unsigned *size;
  string *summary;
  string *group;
  string *description;
  string *packager;
  string *distribution;
  string *vendor;
  string *source_rpm; // sinnvoll?
  string *license;
  string *changelog_name;
  string *changelog_text;
  const char *gif_image; // sinnvoll?
  const char *xpm_image; // sinnvoll?
  const char *icon;
};
\end{verbatim}

Die Beschreibungsdaten k"onnen zur Speicherplatzersparnis erst bei
Bedarf nachgeladen werden. (Daher alles als Pointer, die 0 sein
k"onnen.) Effizienter ist es wahrscheinlich auch (um viele
Massenspeicherzugriffe zu vermeiden), manche Daten zusammen in Gruppen
abzuspeichern, selbst wenn nicht alle verlangt wurden. Welche Daten
sofort gespeichert werden und welche in welchen Gruppen nachgeladen
werden sollen, um beste Effizienz zu erreichen, kommt auf das
Zugriffsprofil an. Ein Vorschlag (geraten) w"are:
\begin{description}
\item[immer speichern:] \texttt{summary}
\item[Gruppe 1:] relativ viel Speicherbedarf: \texttt{description},
\texttt{gif\_image}, \texttt{xpm\_image}, \texttt{icon}
\item[Gruppe 2:] eher "ofter ben"otigt: \texttt{group},
  \texttt{license}, \texttt{size}
\item[Gruppe 3:] eher seltener ben"otigt: Rest
\end{description}


\section{Paketmengen}
Die Klasse \texttt{PkgSet} fa"st Pakete zu Mengen zusammen. In einer
solchen Menge darf ein Paketname nur einmal auftreten. Dies wird
forciert, indem bei Bedarf die neueste m"ogliche Version gew"ahlt
wird. \texttt{PkgSet}s werden normalerweise von
\texttt{PkgDb::make\_set} konstruiert.

Die Auswahl eines bestimmten Paketsets als Default-available-Menge
entspricht dem "`Filter"', d.h. einer Beschr"ankung der zur Verf"ugung
stehenden Pakete.

Weitere \texttt{PkgSet}s sind die installed-Menge und die Kandidaten
der Installation (Input der Engine).

\begin{verbatim}
class PkgSet {
  // enthaltene Pakete
  list<PkgNameEd> contents;
  // Invertierungen der Paketrelationen
  hash<PkgName,list<PkgRevRelation>> needed, conflicted, provided, obsoleted;
}
\end{verbatim}

Die \texttt{contents}-Liste mu"s "`inkrementelles Durchlaufen"'
erlauben, d.h. w"ahrend des Durchlaufens k"onnen hinten weitere Pakete
angh"angt werden, die von der gleichen Schleife auch ber"ucksichtigt
werden (für Erweitern der candidates-Menge).

Die invertierten Relationen werden von der Engine ben"otigt, um
schnell die Erf"ullbarkeit von Paketrelationen entscheiden zu k"onnen.
Der Werttyp der Hashes enth"alt sowohl einen R"uckverweis auf das
Paket, das required, providet etc., als auch einen Verweis auf die
ausl"osende Relation (um die Versionsanforderung schnell sehen zu
k"onnen). Evtl. k"onnte man auch einen weiteren Hash anstelle einer
Liste verwenden, um schnell pr"ufen zu k"onnen, ob ein bestimmtes
Paket etwas providet etc. Das L"oschen von Paketen aus einer Menge und
das Obsoletes-Handling wird dadurch etwas schneller.

Die inversen Relationen werden von der \texttt{add}-Methode von
\texttt{PkgSet} aufgebaut, d.h. beim Hinzuf"ugen eines Pakets werden
gleichzeitig die inversen Relationen aktualisiert. (dito beim L"oschen
eines Pakets.)


\section{\texttt{PkgDependencyCheck}}

Dies ist die Haupt-Interfaceklasse f"ur den Benutzer. Die wichtigste
Methode ist
\begin{quote}
  \verb+bool check_deps( PkgSet candidates,+ \\
  \verb+                 PkgResult& good, PkgResult& bad,+ \\
  \verb+                 [opt] PkgSet available )+
\end{quote}
Die Kandidaten sind die gew"unschten Pakete. Die Angabe von
\texttt{available} ist optional. Wenn sie nicht vorhanden ist, wird
das aktuelle Default-available-Set benutzt.

Die Ergebnisse kommen in zwei Teillisten zur"uck: Die "`guten"'
Pakete, d.h. die ohne Fehler, und die "`schlechten"'. Wenn Fehler
aufgetreten sind, ist der R"uckgabewert \texttt{false}, sonst
\texttt{true}. Die Klasse \texttt{PkgResult} enth"alt neben
Paketnamen- und Edition weitere n"utzliche Informationen: (noch
informelle Beschreibung)
\begin{itemize}
\item referer-Liste (Pakete, die dieses Paket brauchen, mit
zus"atzlicher Angabe der genauen Relation)
\item \texttt{is\_upgrade\_from} bzw. \texttt{is\_downgrade\_from}:
Angabe der bisher installierten Version, wenn es kein neues Paket ist.
Diese Angabe kann zum einen zur Auswahl der \texttt{rpm}-Option
verwendet werden, zum anderen erm"oglicht sie Warnungen vor
Downgrades.
\item \texttt{from\_input\_list}: gesetzt, wenn in der urspr"unglichen
Kandidatenmenge bereits vorhanden
\item \texttt{upgrade\_to\_remove\_conflict}: Ist gesetzt, wenn dieses
Paket geupgradet wurde, um einen Konflikt zu beseitigen (sonst w"are
das Upgrade nicht n"otig gewesen)
\item \texttt{unresolvable}: Dieses Flag ist bei Paketen definiert,
bei denen nicht alle Requirements erf"ullt werden konnten.
\item \texttt{not\_available}: Dieses Paket wird ben"otigt, ist aber
nicht vorhanden; zus"atzliche Angabe der ben"otigten Version
\item \texttt{alternatives}: Dieses Paket ist eine Alternative, die
nicht automatisch aufgel"ost wurde. Der Aufrufer kann zwischen den
hier angegebenen Alternativen entscheiden.
\item \texttt{conflicts\_with}: Dieses Paket steht in Konflikt mit
einem anderen (+ genauere Anagbe welcher Konflikt, noch zu
spezifizieren).
\item \texttt{remove\_to\_solve\_conflict}: Liste von Paketen, die
deinstalliert werden m"u"sten, um einen Konflikt zu beseitigen.
\end{itemize}
Au"ser den ersten vier Infos sind alle nur bei "`schlechten"' Paketen
vorhanden.

Weitere Methoden von \texttt{PkgDependencyCheck} sind
\texttt{select\_available\_set} zur Auswahl der
Default-available-Menge und \texttt{set\_alternative\_handling} zur
Wahl des Modus, wie Alternativen behandelt werden (nie fragen, immer
fragen, nach Default aufl"osen und nur im Notfall fragen).


\section{TODO: Versionsnummern}
Man k"onnte evtl. Versionsnummern (\texttt{PkgEdition}) "ahnlich wie
Paketnamen auf IDs abbilden (bisher sind sie einfache Strings). Das
w"urde teilweise Speicherplatz sparen, andererseits "ubertr"agt sich
nur der Gleichheitsvergleich auf die IDs, f"ur die anderen Vergleiche
m"u"ste man wieder auf die Strings zur"uckgreifen. Die
Versionsvergleiche k"onnten jedoch laufzeitrelevant sein. Evtl. w"are
eine Art Cache f"ur Vergleichergebnisse sinnvoll, dieser w"are aber
deutlicher einfacher mit IDs anstatt mit Strings zu realisieren.


\section{Implementierende Klassen}
\begin{itemize}
\item \texttt{list} (STL)
\item selbstorganisierende Hashes, d.h. bei zu dichter Belegung
      automatisches Vergr"o"sern
\end{itemize}


\end{document}
