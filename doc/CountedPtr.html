<HTML>
<HEAD>
<TITLE>Counted Pointers</TITLE>
</HEAD>
<BODY bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#000099" alink= "#ffffff">

<!-- ****************************************************************************** -->
<H1>Motivation</H1>

<p> The idea is to make pointers into (dynamically allocated) real objects. Every time a
pointer is copied, its <CODE>operator=</CODE> or copy constructor is called, so the number of
outstanding references to an object is tracked in a single data object shared by multiple
counted pointers. When a pointer goes out of scope, its destructor is called and the refernce
count is accordingly decremented. When the count goes to zero, the data object is deleted.
</p>
<p> The only trick is to take control of invocations of the <CODE>-></CODE> operator on an
object using operator overloading.
</p>

<center><table bgcolor="#BEEAE0" border="0">
<tr><td><img src="CountedPtr.png"></td></tr>
<tr><td ><pre>
DataPtr a( new Data );
DataPtr b = a;
...
b->func();  // invokes Data::func()
</pre></td></tr>
</table></center>

<p>There are various ways to implement pointer classes. The approach described here, and
currently used for data objects like Packages, is for shure the most simple one. A data
object like a Package is created once and explicitly shared between all pointer objects
that reference it. I.e. no copy on write is performed. Changes to the data object will be
immediately visible at all locations.
</p>

<!-- ****************************************************************************** -->
<H1>Things provided by <CODE>liby2util</CODE></H1>

<table bgcolor="#BEEAE0" border="0" width="100%">
<tr><td><A HREF="autodocs/Rep.html"><CODE>class Rep</CODE></A></td>
    <td>Base for data classes. Provides the reference counter.</td></tr>
<tr><td><A HREF="autodocs/constRepPtr.html"><CODE>class constRepPtr</CODE></A></td>
    <td>Base for pointer classes providing <CODE>const Rep *</CODE>. Manages reference
        counting.</td></tr>
<tr><td><A HREF="autodocs/RepPtr.html"><CODE>class RepPtr</CODE></A></td>
    <td>Base for pointer classesproviding <CODE>Rep *</CODE>. Manages reference
        counting.</td></tr>
<tr><td><CODE>#include &lt;y2util/RepDef.h></CODE></td>
    <td>Provides a set of macros to create data and pointer classes.</td></tr>
</table>

<!-- ****************************************************************************** -->
<H1>Creating data and pointer classes with <CODE>y2util/RepDef.h</CODE></H1>

<p>The macros provided by <CODE>y2util/RepDef.h</CODE> ease creating a hierarchy of data and
pointer classes like for example:
</p>

<center><table bgcolor="#BEEAE0" border="0">
<tr><td><img src="Rep.png"></td></tr>
</table></center>

<p>If you wonder why there are two pointer classes <CODE>constDataPtr</CODE> and
<CODE>DataPtr</CODE> used, keep in mind that a <CODE>DataPtr</CODE> is nothing but a
<CODE>Data *</CODE>. Thus a <CODE>const DataPtr</CODE> is a <CODE>Data *const</CODE>.
While a <CODE>const Data *</CODE> is provided by <CODE>constDataPtr</CODE>.
</p>

<table bgcolor="#BEEAE0" border="0" width="100%">
<tr><td colspan=2><b>Confused? Throughout your code</b></td></tr>
<tr><td><b>use</b></td><td><b>instead of</b></td></tr>
<tr><td><CODE>constDataPtr</CODE></td>       <td>const Data *</td></tr>
<tr><td><CODE>DataPtr</CODE></td>            <td>Data *</td></tr>
<tr><td>const <CODE>constDataPtr</CODE></td> <td>const Data *const</td></tr>
<tr><td>const <CODE>DataPtr</CODE></td>      <td>Data *const</td></tr>
</table>

<p> Construction, assignment, and implicit conversion on pointer classes will follow the
same rules as with traditional pointers. And like traditional pointers, you'll have to test
for <CODE>!= NULL</CODE> before trying to access the data object using the
<CODE>-></CODE> operator.
</p>

<p> A little bit different is the situation, if you want to cast up the pointer class
hierarchy. Something like <CODE>dynamic_cast&lt;PackagePtr>(ObjectPtr)</CODE> will not
necessarily return the expected result. It's possible that an <CODE>ObjectPtr</CODE>
references a <CODE>Package</CODE> object, whithout in fact being a
<CODE>PackagePtr</CODE>.
</p>

<p> This is solved by being able to construct a pointer class, with respect to constness,
out of the inherited base pointer class (the bottommost class). You can create a
<CODE>constPackagePtr</CODE> out of a <CODE>constSolvablePtr</CODE> or any pointer class
that inherits it (<CODE>constObjectPtr</CODE>, <CODE>SolvablePtr</CODE>, and
<CODE>ObjectPtr</CODE>). The same way a <CODE>PackagePtr</CODE> can be created out of any
pointer class inhertiting <CODE>SolvablePtr</CODE> (<CODE>ObjectPtr</CODE>). If the base
pointer class does not actually reference a <CODE>Package</CODE> object, the created
<CODE>PackagePtr</CODE> will be <CODE>NULL</CODE>.
</p>

<!-- ****************************************************************************** -->
<H2>Creating base classes</H2>

<p> In the example above the base class is class <CODE>Solvable</CODE>, and that is how
you would create it:
</p>

<table bgcolor="#BEEAE0" border="0" width="100%">
<tr><td><PRE>
<B>#include &lt;y2util/RepDef.h></B>

///////////////////////////////////////////////////////////////////
// Define classes constSolvablePtr and SolvablePtr
///////////////////////////////////////////////////////////////////
<B>DEFINE_BASE_POINTER(Solvable);</B>
</PRE></td><td><CODE>SolvablePtr.h</CODE></td></tr>
<tr><td><PRE>
#include &lt;iosfwd>

<B>#include "SolvablePtr.h"</B>

<B>class Solvable : virtual public Rep</B> {
  <B>REP_BODY(Solvable);</B>

  // The rest is up to class Solvable...
  public:
    Solvable() {}
    virtual ~Solvable() {}
    ...
    <B>virtual std::ostream & dumpOn( std::ostream & str ) const;</B>
};
</PRE></td><td><CODE>Solvable.h</CODE></td></tr>
<tr><td><PRE>
#include &lt;iostream>

<B>#include "Solvable.h"</B>

///////////////////////////////////////////////////////////////////
// Implementation of constSolvablePtr and SolvablePtr
///////////////////////////////////////////////////////////////////
<B>IMPL_BASE_POINTER(Solvable);</B>

// The rest is up to class Solvable...

<B>std::ostream & Solvable::dumpOn( std::ostream & str ) const {
  ...
  return str;
}</B>
</PRE></td><td><CODE>Solvable.cc</CODE></td></tr>
</table>

<p> As you can see, it's quite simple. Note that it's <b>always the name of the data class
that's used as macro argument</b>.
</p>

<p> The pointer class definition is kept in a separate
header file <CODE>SolvablePtr.h</CODE>. Including it in your source serves the same purpose
as a forward declaration <CODE>class Solvable;</CODE>. You may use the pointer classes,
but can't access class <CODE>Solvable</CODE>.
</p>

<p> The <CODE>REP_BODY</CODE> macro serves as hook to overload or introduce methods that
may become necessary. Currently just overloads <CODE>Rep::rep_name()</CODE> to return the
class name <CODE>"Solvable"</CODE>.
</p>

<p> As there is an <CODE>std::ostream::operator &lt;&lt;</CODE> provided for class
<CODE>Rep</CODE>, that simply calls <CODE>Rep::dumpOn</CODE>, overloading
<CODE>Rep::dumpOn</CODE> is a simple way to realize a <CODE>std::ostream::operator
&lt;&lt;</CODE> for class <CODE>Solvable</CODE>.
</p>

<!-- ****************************************************************************** -->
<H2>Creating derived classes</H2>

<p> Creating derived classes is almost the same as creating base classes. Just two
different macros <CODE>DEFINE_DERIVED_POINTER</CODE> and <CODE>IMPL_DERIVED_POINTER</CODE>
are needed to define and implement the pointer classes. Macro arguments for both macros
are:
<UL>
<LI><CODE>NAME</CODE>: The name of the data class.
<LI><CODE>FROM</CODE>: The name of the data class it is derived from.
<LI><CODE>BASE</CODE>: The name of the base data class (the bottommost class)
</Ul>

<table bgcolor="#BEEAE0" border="0" width="100%">
<tr><td><PRE>
<B>#include "SolvablePtr.h"</B>

///////////////////////////////////////////////////////////////////
// Define classes constObjectPtr and ObjectPtr
///////////////////////////////////////////////////////////////////
<B>DEFINE_DERIVED_POINTER(Object,Solvable,Solvable);</B>
</PRE></td><td><CODE>ObjectPtr.h</CODE></td></tr>
<tr><td><PRE>
#include &lt;iosfwd>

<B>#include "ObjectPtr.h"</B>
<B>#include "Solvable.h"</B>

<B>class Object : virtual public Rep, public Solvable</B> {
  <B>REP_BODY(Object);</B>

  // The rest is up to class Object...
  public:
    Object() {}
    virtual ~Object() {}
    ...
    <B>virtual std::ostream & dumpOn( std::ostream & str ) const;</B>
};
</PRE></td><td><CODE>Object.h</CODE></td></tr>
<tr><td><PRE>
#include &lt;iostream>

<B>#include "Object.h"</B>

///////////////////////////////////////////////////////////////////
// Implementation of constObjectPtr and ObjectPtr
///////////////////////////////////////////////////////////////////
<B>IMPL_DERIVED_POINTER(Object,Solvable,Solvable);</B>

// The rest is up to class Object...

<B>std::ostream & Object::dumpOn( std::ostream & str ) const {
  ...
  return str;
}</B>
</PRE></td><td><CODE>Object.cc</CODE></td></tr>
</table>


<p> And the same way <CODE>Object</CODE> was derived from <CODE>Solvable</CODE>,
<CODE>Package</CODE> will be derived from <CODE>Object</CODE>:
</p>


<table bgcolor="#BEEAE0" border="0" width="100%">
<tr><td><PRE>
<B>#include "ObjectPtr.h"</B>

///////////////////////////////////////////////////////////////////
// Define classes constPackagePtr and PackagePtr
///////////////////////////////////////////////////////////////////
<B>DEFINE_DERIVED_POINTER(Package,Object,Solvable);</B>
</PRE></td><td><CODE>PackagePtr.h</CODE></td></tr>
<tr><td><PRE>
#include &lt;iosfwd>

<B>#include "PackagePtr.h"</B>
<B>#include "Object.h"</B>

<B>class Package : virtual public Rep, public Object</B> {
  <B>REP_BODY(Package);</B>

  // The rest is up to class Package...
  public:
    Package() {}
    virtual ~Package() {}
    ...
    <B>virtual std::ostream & dumpOn( std::ostream & str ) const;</B>
};
</PRE></td><td><CODE>Package.h</CODE></td></tr>
<tr><td><PRE>
#include &lt;iostream>

<B>#include "Package.h"</B>

///////////////////////////////////////////////////////////////////
// Implementation of constPackagePtr and PackagePtr
///////////////////////////////////////////////////////////////////
<B>IMPL_DERIVED_POINTER(Package,Object,Solvable);</B>

// The rest is up to class Package...

<B>std::ostream & Package::dumpOn( std::ostream & str ) const {
  ...
  return str;
}</B>
</PRE></td><td><CODE>Package.cc</CODE></td></tr>
</table>

<!-- ****************************************************************************** -->
</BODY>
</HTML>
