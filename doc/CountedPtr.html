<HTML><HEAD><TITLE>Counted Pointers</TITLE></HEAD>
<BODY bgcolor="#c8c8c8">
<TABLE WIDTH="100%"><TR><TD ALIGN="left" VALIGN="top"><i>YaST2 Developers Documentation: </i><b> Counted Pointers </b></TD><TD ALIGN="RIGHT" VALIGN="TOP"><img src="/usr/share/doc/packages/ydoc/images/yast2-mini.png"></TD></TR></TABLE>
<hr>
<table width="100%"><tr>
<td valign=top align=center><img src="/usr/share/doc/packages/ydoc/images/yast2-half.png"><br><br><center><a HREF="autodocs/index.html">Class index</A><br><A HREF="autodocs/heir.html">Hierarchy</A><br><a href="autodocs/intro.html">Introduction</a></center></td>
<td width="100%" valign=top>
<table cellspacing=0 BGCOLOR="#f96500" width="100%"><tr><td>
<table width="100%" bgcolor="#ffc080" cellpadding=10><TR><TD>
<P><H1><font color="#e00000">Counted Pointers</font></H1>
</td></tr>
<tr><td>
 <table width="100%">
  <tr><td><A HREF="autodocs/Rep.html"><CODE>class Rep</CODE></A></td>
      <td>Base for data classes. Provides the reference counter.</td></tr>
  <tr><td><A HREF="autodocs/constRepPtr.html"><CODE>class constRepPtr</CODE></A></td>
      <td>Base for const pointer classes. Manages reference counting.</td></tr>
  <tr><td><A HREF="autodocs/RepPtr.html"><CODE>class RepPtr</CODE></A></td>
      <td>Base for pointer classes. Manages reference counting.</td></tr>
 </table>
</td></tr>
</table>
</td></tr></table>
</TD></TR></TABLE>
<H2>Detailed Description</H2>
<P>
<p> The idea is to make pointers into (dynamically allocated) real objects. Every time a
pointer is copied, its <CODE>operator=</CODE> or copy constructor is called, so the number of
outstanding references to an object is tracked in a single data object shared by multiple
counted pointers. When a pointer goes out of scope, its destructor is called and the refernce
count is accordingly decremented. When the count goes to zero, the data object is deleted.
</p>
<p> The only trick is to take control of invocations of the <CODE>-></CODE> operator on an
object using operator overloading.
</p>
<center><table >
<tr><td><img src="CountedPtr.png"></td></tr>
<tr><td><PRE>
DataPtr a( new Data );
DataPtr b = a;
...
b->func();  // invokes Data::func()
</PRE></td></tr>
</table></center>


<H2>Data Classes</H2>

<p> The only thing data classes need is a reference counter provided by virtual inheritance
of <CODE>class Rep</CODE>.
</p>

<table border=0 cellspacing=0 width="100%" bgcolor="#f96500" cellpadding=1><tr><td><table width="100%" bgcolor="#ffc080" cellspacing=0 cellpadding=3 border=0><tr><td>
<PRE>
<B>class Data : virtual public <A HREF="autodocs/Rep.html">Rep</A></B> {

  public:
    <B>// You might want to overload these two, but you don't have to</B>
    <B>(1) virtual const char *   rep_name() const { return "Data"; }</B>
    <B>(2) virtual std::ostream & dumpOn( std::ostream & str ) const;</B>

  // The rest is up to class Data...
  private:
    ...
  public:
    Data();
    virtual ~Data();
    ....
};
</PRE>
</td></tr></table></td></tr></table>

<H4><CODE>(1) virtual const char * Rep::rep_name() const</CODE></H4>

<p> Mainly for debug purpose <CODE>Rep::dumpOn</CODE> writes out the objects name, address and
reference count. If you like, overload <CODE>rep_name</CODE> and let it return eg. the
class name. This way it will appear as name on the debug line.
</p>

<H4><CODE>(2) virtual std::ostream & Rep::dumpOn( std::ostream & str ) const</CODE></H4>

<p> There is an <CODE>std::ostream operator <<</CODE> provided for <CODE>Rep</CODE>, which
simply calls <CODE>Rep::dumpOn</CODE>. Thus overloading <CODE>Rep::dumpOn</CODE> has the same
effect as defining an <CODE>std::ostream operator <<</CODE> for <CODE>Data</CODE>.


<H2>Pointer Classes</H2>

<p> There are various ways to implement pointer classes. The approach based on
<CODE>constRepPtr</CODE> and <CODE>RepPtr</CODE>, and currently used for data objects
like Packages, is for shure the most simple one.
</p>
<p> A data object like a Package is created once and explicitly shared between all
pointer objects that reference it. I.e. no copy on write is performed. Changes to the
data object will be immediately visible at all locations.
</p>
<p> A <CODE>DataPtr</CODE> is nothing else but a <CODE>Data *</CODE> and it can be
passed as parameter, assigned, created, destroyed, etc. the same way. Thus a
<CODE>const DataPtr</CODE> is a <CODE>Data *const</CODE>. As we may want to use
<CODE>const Data *</CODE> as well, we provide another class <CODE>constDataPtr</CODE>
for it.
</p>
<table border=0 cellspacing=0 width="100%" bgcolor="#f96500" cellpadding=1><tr><td><table width="100%" bgcolor="#ffc080" cellspacing=0 cellpadding=3 border=0>
<tr><td colspan=2><b>Confused? Throughout your code</b></td></tr>
<tr><td><b>use</b></td><td><b>instead of</b></td></tr>
<tr><td><CODE>constDataPtr</CODE></td>       <td>const Data *</td></tr>
<tr><td><CODE>DataPtr</CODE></td>            <td>Data *</td></tr>
<tr><td>const <CODE>constDataPtr</CODE></td> <td>const Data *const</td></tr>
<tr><td>const <CODE>DataPtr</CODE></td>      <td>Data *const</td></tr>
</table></td></tr></table>

<p> Construction, assignment and implicit conversion should behave as expected. Whereever
a <CODE>constDataPtr</CODE> is expected, a <CODE>DataPtr</CODE> can be used as well, but not
vice versa.
</p>
<p> In case you derive from data and pointer classes the way described below, the new pointer
classes will inherit their base pointer classes the same way, the new data class inherits the
base class.
</p>
<p> Assume you derive <CODE>class MoreData</CODE> from <CODE>class Data</CODE>, then <CODE>constMoreDataPtr</CODE>
will inherit <CODE>constDataPtr</CODE> and <CODE>MoreDataPtr</CODE> will inherit <CODE>DataPtr</CODE>.
</p>
<p> Thus implicit conversion of pointer classes into corresponding base pointer classes
should follow the same rules as with traditional pointers. Whereever a <CODE>constDataPtr</CODE>
is expected, any <CODE>constMoreDataPtr</CODE> or <CODE>MoreDataPtr</CODE> can be used. Whereever
a <CODE>DataPtr</CODE> is expected, any <CODE>MoreDataPtr</CODE> can be used.
</p>
<p> A little bit different is the situation, if you want to cast up the pointer class hierarchy,
Something like <CODE>dynamic_cast<MoreDataPtr>(DataPtr)</CODE> would not necessarily return the
expected result. It's possible that the <CODE>DataPtr</CODE> references a <CODE>MoreData</CODE>
object, whithout in fact being a <CODE>MoreDataPtr</CODE>.
</p>
<p> To solve this, you can constuct any pointer class out of any other pointer class, or assign
any other pointer class. The same way as a <CODE>dynamic_cast<MoreData *>(Data *)</CODE> will
return <CODE>NULL</CODE>, if the <CODE>Data *</CODE> is not in fact a <CODE>MoreData *</CODE>,
the pointer class will point to <CODE>NULL</CODE>, if the assigned pointer class does not reference
an appropriate data class.
</p>
<table border=0 cellspacing=0 width="100%" bgcolor="#f96500" cellpadding=1><tr><td><table width="100%" bgcolor="#ffc080" cellspacing=0 cellpadding=3 border=0><tr><td>
<PRE>
DataPtr     m( new MoreData );
DataPtr     d( new Data );

MoreDataPtr a( m ); // references the same MoreData object as m
MoreDataPtr b( d ); // points to NULL
</PRE>
</td></tr></table></td></tr></table>
<p> Because the pointer classes described here do not provide any datatypes or interface
functions, just a plain pointer, thay can be easily created using some <b>macros defined in
<CODE>#include &lt;y2util/RepDef.h></CODE></b>. This way changes that may become necessary
can easily be distributed throughout the code.
</p>

<H2>Creating base classes with y2util/RepDef.h</H2>

<p> The example uses three files to implement <CODE>class Data</CODE> and the related pointer classes
<CODE>constDataPtr</CODE> and <CODE>constDataPtr</CODE>. See the next section on how to derive from
<CODE>class Data</CODE> and create the associated pointer classes.
</p>

<table border=0 cellspacing=0 width="100%" bgcolor="#f96500" cellpadding=1><tr><td><table width="100%" bgcolor="#ffc080" cellspacing=0 cellpadding=3 border=0>
<tr><td valign=top><CODE>Data.h</CODE></td>
    <td>Full definition of <CODE>class Data</CODE> and provides <CODE>DataPtr.h</CODE> as well.</td></tr>
<tr><td valign=top><CODE>DataPtr.h</CODE></td>
    <td>This one defines the two pointer classes, but does not provide any information about
    <CODE>class Data</CODE> itself. Including it in your source serves the same purpose as a
    forward declaration of <CODE>class Data</CODE>. You may use the pointer classes, but can't
    access <CODE>class Data</CODE>.</td></tr>
<tr><td valign=top><CODE>Data.cc</CODE></td>
    <td>Macro implementation of pointer class methods and most probabely for <CODE>class Data</CODE> too. </td></tr>
</table></td></tr></table>


<H4>Data.h</H4>

<table border=0 cellspacing=0 width="100%" bgcolor="#f96500" cellpadding=1><tr><td><table width="100%" bgcolor="#ffc080" cellspacing=0 cellpadding=3 border=0><tr><td>
<PRE>
#ifndef Data_h
#define Data_h

#include &lt;iosfwd&gt;

<B>#include &lt;y2pm/DataPtr.h></B>

///////////////////////////////////////////////////////////////////
// CLASS NAME : Data
///////////////////////////////////////////////////////////////////
<B>class Data : virtual public Rep</B> {
  <B>REP_BODY(Data);               // the ';' to make ydoc happy</B>

  // The rest is up to class Data...
  private:
    ...
  public:
    Data();
    virtual ~Data();
    ....
    <B>virtual std::ostream & dumpOn( std::ostream & str ) const;</B>
};
#endif // Data_h
</PRE>
</td></tr></table></td></tr></table>

<p> <CODE>REP_BODY(Data)</CODE> currently overloads <CODE>Rep::rep_name()</CODE> to return the
class name <CODE>"Data"</CODE>. You should use it anyway, as it serves as hook to overload or introduce
other functions that may become necessary.
</p>
<p> Overloading <CODE>Rep::dumpOn</CODE> is optional.
</p>


<H4>DataPtr.h</H4>

<table border=0 cellspacing=0 width="100%" bgcolor="#f96500" cellpadding=1><tr><td><table width="100%" bgcolor="#ffc080" cellspacing=0 cellpadding=3 border=0><tr><td>
<PRE>
#ifndef DataPtr_h
#define DataPtr_h

<B>#include &lt;y2util/RepDef.h&gt;</B>

///////////////////////////////////////////////////////////////////
// CLASS NAME : DataPtr
// CLASS NAME : constDataPtr
///////////////////////////////////////////////////////////////////
<B>DEFINE_BASIC_HANDLES(Data);</B>

#endif // DataPtr_h
</PRE>
</td></tr></table></td></tr></table>

<p> <CODE>DEFINE_BASIC_HANDLES(Data);</CODE> provides the definition of classes
<CODE>DataPtr</CODE> and <CODE>constDataPtr</CODE>. Using traditional pointers it
would contain nothing but <CODE>class Data;</CODE>.
</p>

<H4>Data.cc</H4>

<table border=0 cellspacing=0 width="100%" bgcolor="#f96500" cellpadding=1><tr><td><table width="100%" bgcolor="#ffc080" cellspacing=0 cellpadding=3 border=0><tr><td>
<PRE>
#include &lt;iostream&gt;

<B>#include &lt;y2pm/Data.h&gt;</B>

using namespace std;

///////////////////////////////////////////////////////////////////
// CLASS NAME : DataPtr
// CLASS NAME : constDataPtr
///////////////////////////////////////////////////////////////////
<B>IMPL_HANDLES(Data);</B>

///////////////////////////////////////////////////////////////////
// CLASS NAME : Data
///////////////////////////////////////////////////////////////////
Data::Data()
{}

Data::~Data()
{}

ostream & Data::dumpOn( ostream & str ) const
{
  Rep::dumpOn( str );
  return str;
}
</PRE>
</td></tr></table></td></tr></table>

<p> <CODE>IMPL_HANDLES(Data);</CODE> provides the necessary implementation for classes
<CODE>DataPtr</CODE> and <CODE>constDataPtr</CODE>. At the point you use it, definition of
pointer classes and <CODE>class Data</CODE> must be available.
</p>
<p> The remainder of the file is up to the needs of <CODE>class Data</CODE>.
</p>


<H2>Creating derived classes with y2util/RepDef.h</H2>


<p> Deriving from existing data and pointer classes is almost the same as creating the
base classes. It's just another macro that's needed to define the derived pointer classes in
<CODE>MoreDataPtr.h</CODE>.
</p>
<p> The example shows how to derive <CODE>class MoreData</CODE> from <CODE>class Data</CODE>,
and how to create the pointer classes <CODE>MoreDataPtr</CODE> and <CODE>constMoreDataPtr</CODE>.
</p>

<H4>MoreData.h</H4>

<table border=0 cellspacing=0 width="100%" bgcolor="#f96500" cellpadding=1><tr><td><table width="100%" bgcolor="#ffc080" cellspacing=0 cellpadding=3 border=0><tr><td>
<PRE>
#ifndef MoreData_h
#define MoreData_h

#include &lt;iosfwd&gt;

<B>#include &lt;y2pm/MoreDataPtr.h&gt;</B>
<B>#include &lt;y2pm/Data.h&gt;</B>

///////////////////////////////////////////////////////////////////
// CLASS NAME : MoreData
///////////////////////////////////////////////////////////////////
<B>class MoreData : virtual public Rep, public Data</B> {
  <B>REP_BODY(MoreData);               // the ';' to make ydoc happy</B>

  // The rest is up to class MoreData...
  private:
    ...
  public:
    MoreData();
    virtual ~MoreData();
    ....
    <B>virtual std::ostream & dumpOn( std::ostream & str ) const;</B>
};
#endif // MoreData_h
</PRE>
</td></tr></table></td></tr></table>

<p> <CODE>REP_BODY(MoreData)</CODE> again overloads <CODE>Rep::rep_name()</CODE> to return the
class name <CODE>"MoreData"</CODE>. You should use it anyway, as it serves as hook to overload
or introduce other functions that may become necessary.
</p>
<p> Overloading <CODE>Rep::dumpOn</CODE> is optional.
</p>

<H4>MoreDataPtr.h</H4>

<table border=0 cellspacing=0 width="100%" bgcolor="#f96500" cellpadding=1><tr><td><table width="100%" bgcolor="#ffc080" cellspacing=0 cellpadding=3 border=0><tr><td>
<PRE>
#ifndef MoreDataPtr_h
#define MoreDataPtr_h

<B>#include &lt;y2pm/DataPtr.h&gt;</B>

///////////////////////////////////////////////////////////////////
// CLASS NAME : MoreDataPtr
// CLASS NAME : constMoreDataPtr
///////////////////////////////////////////////////////////////////
<B>DEFINE_DERIVED_HANDLES( MoreData, public, Data );</B>

#endif // MoreDataPtr_h
</PRE>
</td></tr></table></td></tr></table>

<p> <CODE>DEFINE_DERIVED_HANDLES( MoreData, public, Data );</CODE> provides the definition of classes
<CODE>MoreDataPtr</CODE> and <CODE>constMoreDataPtr</CODE> derived from <CODE>DataPtr</CODE> and <CODE>constDataPtr</CODE>.
Note that the macro arguments are always the names of the corresponding data classes.
</p>

<H4>MoreData.cc</H4>

<table border=0 cellspacing=0 width="100%" bgcolor="#f96500" cellpadding=1><tr><td><table width="100%" bgcolor="#ffc080" cellspacing=0 cellpadding=3 border=0><tr><td>
<PRE>
#include &lt;iostream&gt;

<B>#include &lt;y2pm/MoreData.h&gt;</B>

using namespace std;

///////////////////////////////////////////////////////////////////
// CLASS NAME : MoreDataPtr
// CLASS NAME : constMoreDataPtr
///////////////////////////////////////////////////////////////////
<B>IMPL_HANDLES(MoreData);</B>

///////////////////////////////////////////////////////////////////
// CLASS NAME : MoreData
///////////////////////////////////////////////////////////////////
MoreData::MoreData()
{}

MoreData::~MoreData()
{}

ostream & MoreData::dumpOn( ostream & str ) const
{
  Rep::dumpOn( str );
  return str;
}
</PRE>
</td></tr></table></td></tr></table>

<p> <CODE>IMPL_HANDLES(MoreData);</CODE> again provides the necessary implementation for classes
<CODE>MoreDataPtr</CODE> and <CODE>constMoreDataPtr</CODE>.
</p>


<hr>
<TABLE WIDTH="100%"><TR><TD ALIGN="left" VALIGN="top"><i>YaST2 Developers Documentation: </i><b> Counted Pointers </b></TD><TD ALIGN="RIGHT" VALIGN="TOP"><img src="/usr/share/doc/packages/ydoc/images/yast2-mini.png"></TD></TR></TABLE>
</BODY></HTML>

